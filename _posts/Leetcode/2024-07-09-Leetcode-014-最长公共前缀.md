---
layout: post
title: "14. 最长公共前缀 - 力扣（LeetCode）"
subtitle: "难度：Easy"
date: 2024-07-09 20:42:00
author: "WenXingming"
published: true
catalog: true
# header-img: "img/post-bg-2015.jpg"
# header-style: text
tags:
  - Leetcode


---

# 题目链接

[14. 最长公共前缀 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-prefix/description/)

# Code 1

刚开始看到这题时，第一想法是 “从0到多” 不断增加 longestCommonPreStr 的长度。

```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.empty()) return string{""};
        if (strs.size() == 1) return strs[0];

        string resStr {};
        for (int i = 0; i < strs[0].size(); ++i){
            char c = strs[0][i];
            for (int j = 1; j < strs.size(); ++j){
                if(i >= strs[j].size() || strs[j][i] != c){
                    return resStr;
                }
            }
            resStr += c;
        }
        return resStr;
    }
};
```

# Code 2

**另一种思路是：化繁为简。**我们需要判断多个字符串的 longestCommonPreStr，我们可以将**问题简化为只判断两个字符串的 longestCommonPreStr**。

1. 初始化 longestCommonPreStr = strs[0]
2. 判断 longestCommonPreStr 和 strs[1] 两个字符串的 longestCommonPreStr，得到新的 longestCommonPreStr
3. 新的 longestCommonPreStr 和 strs[2] 两个字符串的 longestCommonPreStr，得到新的 longestCommonPreStr
4. ......
5. 最终的 longestCommonPreStr 即是所有多个字符串的 longestCommonPreStr。

```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.empty()) return string{""};
        if (strs.size() == 1) return strs[0];
        
        string resStr = strs[0];
        for(int i = 1; i < strs.size(); ++i){   // 遍历字符串数组 strs，resStr和strs[i] 两两比较
            for (int j = 0; j < resStr.size(); ++j) {
                if (strs[i][j] != resStr[j]) {
					resStr = resStr.substr(0, j);
					break;  // must
				}
            }
            if (resStr.size() == 0) return ""; // “剪枝”
        }
        return resStr;
    }
};
```

