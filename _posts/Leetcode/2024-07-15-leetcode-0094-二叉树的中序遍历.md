---
layout: post
title: "94. 二叉树的中序遍历 - 力扣（LeetCode）"
subtitle: "难度：Easy"
date: 2024-07-15 16:53:28
author: "WenXingming"
published: true
catalog: true
# header-img: "{{baseurl}}/img/xxx"
tags: [Leetcode]
---

# 题目链接

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

# Code（递归）

```C++
class Solution {
	vector<int> res;
public:
	vector<int> inorderTraversal(TreeNode* root) {
		if(root == nullptr) return {};
		inorder(root);
		return res;
	}

	void inorder(TreeNode* root) {	// 主要是中序遍历不需要返回值...
		if (root == nullptr) return;

		if(root->left) inorder(root->left);
		res.push_back(root->val);
		if(root->right) inorder(root->right);
	}	
};
```

# Code（stack）

关键是对**任意一棵（子）树**为参考系，入栈顺序来说**都是**：**右中左，这样出栈时才能左中右**！

```C++
class Solution {
	
public:
	vector<int> inorderTraversal(TreeNode* root) {
		if (root == nullptr) return {};

		vector<int> res;

		stack<pair<TreeNode*, bool>> st;
		st.push({ root, false }); // false表示未访问过，第一次访问时不能访问
		while (!st.empty()) {
			auto tmp = st.top(); st.pop();	// 出栈，false 代表不可以访问（输出到数组）
			if(tmp.second == true) res.push_back(tmp.first->val);
			else {
				// 按右中左的顺序入栈，nullptr 不入栈
				if (tmp.first->right) st.push({ tmp.first->right, false });
				st.push({ tmp.first, true });
				if (tmp.first->left) st.push({ tmp.first->left, false });
			}
		}
		return res;
	}
};
```
