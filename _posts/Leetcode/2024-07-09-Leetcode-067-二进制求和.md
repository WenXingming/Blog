---
layout: post
title: "67. 二进制求和 - 力扣（LeetCode）"
subtitle: "难度：Easy"
date: 2024-07-09 22:48:00
author: "WenXingming"
published: true
catalog: true
# header-img: "img/post-bg-2015.jpg"
# header-style: text
tags:
  - Leetcode
---

# 题目链接

[67. 二进制求和 - 力扣（LeetCode）](https://leetcode.cn/problems/add-binary/description/)

# Code 1（STL，适用于二进制数字符串不是很长的情况）

当位数过多，超出整形容量，则此方法不可用。`bitset<>`对象：构造函数中可用 **（十进制）数字、二进制字符串初始化**。且其提供了转化为数字、字符串的方法：`std::bitset::to_ulong()`、`std::bitset::to_string()`

```C++
#include <bitset>
class Solution {
public:
    string addBinary(string a, string b) {
        if (a.empty()) return b;
        if (b.empty()) return a;

        bitset<32> bitA { a };
        bitset<32> bitB { b };
        int num1 = bitA.to_ulong();
        int num2 = bitB.to_ulong();
        unsigned long sum = num1 + num2;

        bitset<32> bitSum { sum };
        string res = bitSum.to_string();
        res = res.substr(res.find_first_not_of('0'));   // 删去左边的0：找到第一个非0位置，截取子串
        return res;
    }
};
```

# Code 2（模拟）

类似于 Leetcode：002 题

```C++
class Solution {
public:
	string addBinary(string a, string b) {
		if (a.empty()) return b;
		if (b.empty()) return a;

		string res{};
		int carry{ 0 };
		for (int i = a.size() - 1, j = b.size() - 1; i >= 0 || j >= 0; i--, j--) {
			int num1 = (i < 0 ? 0 : a[i] - '0'); // 或者使用 std::stoi()
			int num2 = (j < 0 ? 0 : b[j] - '0');
			int num = (num1 + num2 + carry) % 2;
			carry = (num1 + num2 + carry) / 2;

			res = to_string(num) + res; // 顺序不可变，因为是从后往前加的
		}

		if(carry > 0) res = to_string(carry) + res;
		else return res;
	}
};
```

# Code 3（位运算）

以后再说...
