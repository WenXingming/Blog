---
layout: post
title: "58. 最后一个单词的长度 - 力扣（LeetCode）"
subtitle: "难度：Easy"
date: 2024-07-09 22:06:00
author: "WenXingming"
published: true
catalog: true
# header-img: "img/post-bg-2015.jpg"
# header-style: text
tags:
  - Leetcode


---

# 题目链接

[58. 最后一个单词的长度 - 力扣（LeetCode）](https://leetcode.cn/problems/length-of-last-word/description/)

# Code 1

使用了STL的：`std::find_if()`和`string::rbegin(), string::rend()`，详细用法（`std::distance()`）可以询问 AI、查询手册等。

```C++
class Solution {
public:
    int lengthOfLastWord(string s) {
        if(s.empty())
            return 0;

        auto iter = find_if(s.rbegin(), s.rend(), [](char c) { return c != ' '; }); // 找从后往前的第一个非空格
		auto iter2 = find_if(iter, s.rend(), [](char c) { return c == ' '; });	// 找从 iter 往前的第一个空格
        return std::distance(iter, iter2);
    }
};
```

# Code 2（手搓）

首先明确，要进行**反向遍历**才简单：（因为是求最后一个单词的长度）

```C++
class Solution {
public:
	int lengthOfLastWord(string s) {
		if (s.empty()) return 0;

		int rStart{},rEnd{};
		for (int i = s.size() - 1; i >= 0; --i) {
            if(s[i] != ' '){
				rStart = i;
				break;
			}
		}
		for (int i = rStart; i >= -1; --i) {
            if((i > -1 && s[i] == ' ') || i == -1){	// 注意“左闭右开”即一开一闭，如果字符串s前面没空格，就需要到-1停止
				rEnd = i;
				break;
			}
		}
		return abs(rStart - rEnd);
	}
};
```

# Code 2（手搓）

就是犟，正向遍历（因为只是求长度，而不是具体单词，所以也没有太复杂）。

```C++
class Solution {
public:
	int lengthOfLastWord(string s) {
		if (s.empty()) return 0;

		int preLength{ 0 };
		int curLength{ 0 };
		for (int i = 0; i < s.size(); ++i) {
			if (s[i] == ' ') {
				if(curLength != 0) preLength = curLength;
				curLength = 0;
			}
			else
				curLength++;
		}

		if (curLength != 0) return curLength;
		else return preLength;
	}
};
```
