---
layout: post
title: "70. 爬楼梯 - 力扣（LeetCode）"
subtitle: "难度：Easy"
date: 2024-07-15 15:59:38
author: "WenXingming"
published: true
catalog: true
# header-img: "{{baseurl}}/img/xxx"
tags: [Leetcode]
---

# 题目链接

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

# Code 1（递归）

```C++
//可能会超时，因此需要递归优化
class Solution {
public:
	int climbStairs(int n) {
		if(n == 1) return 1;
		if(n == 2) return 2;
		return climbStairs(n-1) + climbStairs(n-2);
	}
};
```

```C++
//递归优化：剪枝。优化如下。类似 DP
class Solution {
private:
	int arr[46]{};
public:
	int climbStairs(int n) {
		if (n == 1) return arr[1] = 1;
		if(n == 2) return arr[2] = 2;
		if(arr[n] != 0) return arr[n];	// 递归记忆化，已经计算过的直接返回，不再重复计算

		return climbStairs(n-1) + climbStairs(n-2);
	}
};
```

# Code 2（DP, Dynamic Programming）

其基本思想是递归地将一个复杂的问题划分为许多更简单的子问题（分治、问题规约），**存储这些子问题的每个子问题的解**，并最终将存储的答案用于解决原始问题。

```C++
class Solution {
public:
	int climbStairs(int n) {
		int arr[46]{};
		arr[1] = 1; arr[2] = 2;
		for (int i = 3; i <= n; i++) {
			arr[i] = arr[i - 1] + arr[i - 2];
		}
		return arr[n];
	}
};
```

# Code 3（普遍解法）

```C++
class Solution {
public:
	int climbStairs(int n) {
		if (n == 1) return 1;
		if (n == 2) return 2;
		// 要想知道 n 阶楼梯的走法，只需要知道 n-1 和 n-2 的走法即可，故维护两个变量即可
		int first = 1;
		int second = 2;
		int result;
		for (int i = 3; i <= n; i++) {
			result = first + second;
			first = second;
			second = result;
		}
		return result;
	}
};
```
