---
layout: post
title: "1.两数之和-力扣（LeetCode）"
subtitle: "Easy"
date: 2024-07-08 19:25:00
author: "WenXingming"
published: true
catalog: true
# header-img: "img/post-bg-2015.jpg"
# header-style: text
tags:
  - Leetcode
---

# 题目链接

[1.两数之和-力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)

# Code 1：暴力循环

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        if(nums.empty() || nums.size() < 2) return {};

        for(int i = 0; i < nums.size(); ++i){
            for(int j = i+1; j < nums.size(); ++j){
                if(nums[i] + nums[j] == target){
                    vector<int> res = {i,j};
                    return res;
                }
            }
        }
        return {};
    }
};
```

# Code 2：哈希表

这个问题其实就是查找问题：遍历时，要找到 target-nums[i] 是否存在。我们可以利用哈希表（STL中的unordered_map）查找元素很快的特性（或者使用 map 等二叉树查找也很快）

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        if(nums.empty() || nums.size() < 2) return {};

        unordered_map<int, int> numToIndexMap;
        for (int i = 0; i < nums.size(); ++i){
            int findNumber = target - nums[i];
            if(numToIndexMap.find(findNumber) != numToIndexMap.end()){
                return vector<int>{numToIndexMap[findNumber], i};
            }else{
                numToIndexMap[nums[i]] = i;
            }
        }
        return vector<int> {};
    }
};
```

# 单元测试

```C++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

class Solution;
// definition of class Solution

int main(){
    Solution s;
    vector<int> testV = {1,2,3,4,5,6};
    int testTarget = 7;
    vector<int> res = s.twoSum(testV, testTarget);
    std::cout << res[0] << " " << res[1] << std::endl;
    return 0;
}
```

